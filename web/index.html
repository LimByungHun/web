<!DOCTYPE html>
<html>
<head>
  <base href="/">
  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">
  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="sign_web">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">
  <meta name="permissions-policy" content="camera=(self)">
  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <script>
    //  ê¸°ì¡´ ë‹¨ìˆœí•œ ì´ˆê¸°í™” ë°©ì‹ìœ¼ë¡œ ë˜ëŒë¦¬ê¸°
    async function requestCameraPermission() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        stream.getTracks().forEach(track => track.stop());
        console.log(' ì¹´ë©”ë¼ ê¶Œí•œ í—ˆìš©ë¨');
        return true;
      } catch (error) {
        console.error(' ì¹´ë©”ë¼ ê¶Œí•œ ìš”ì²­ ì‹¤íŒ¨:', error);
        return false;
      }
    }

    //  ê¸°ì¡´ ë°©ì‹: ë‹¨ìˆœí•œ OpenCV ë¡œë“œ
    window.cvReady = new Promise((resolve) => {
      const check = () => {
        if (window.cv && window.cv.Mat) {
          console.log(' OpenCV ë¡œë“œ ì™„ë£Œ');
          resolve(true);
        } else {
          setTimeout(check, 100); // 100ms ê°„ê²©ìœ¼ë¡œ ì²´í¬
        }
      };
      
      if (window.cv) {
        window.cv['onRuntimeInitialized'] = () => {
          console.log(' OpenCV Runtime ì´ˆê¸°í™” ì™„ë£Œ');
          resolve(true);
        };
      }
      
      check();
      
      // íƒ€ì„ì•„ì›ƒ: 30ì´ˆ
      setTimeout(() => {
        console.warn(' OpenCV ë¡œë“œ íƒ€ì„ì•„ì›ƒ');
        resolve(false);
      }, 30000);
    });

    //  ì»¬ëŸ¬ ì²˜ë¦¬ ë¡œì§ì€ ê·¸ëŒ€ë¡œ ìœ ì§€
    window.processImageBase64 = function (base64Input) {
      return new Promise((resolve, reject) => {
        // OpenCV ìƒíƒœ í™•ì¸
        if (!window.cv || !window.cv.Mat) {
          console.log(' OpenCV ë¯¸ë¡œë“œ, ì›ë³¸ ì»¬ëŸ¬ ìœ ì§€');
          resolve(base64Input);
          return;
        }

        try {
          const img = new Image();
          img.onload = () => {
            try {
              // ìº”ë²„ìŠ¤ ìƒì„± ë° ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
              const canvas = document.createElement('canvas');
              canvas.width = img.width;
              canvas.height = img.height;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0);

              // OpenCV Mat ìƒì„± (ì»¬ëŸ¬ ìœ ì§€)
              let src = cv.imread(canvas);
              
              // RGBA â†’ RGB ë³€í™˜
              if (src.channels() === 4) {
                cv.cvtColor(src, src, cv.COLOR_RGBA2RGB);
              }
              
              //  ì»¬ëŸ¬ ê¸°ë°˜ ìˆ˜ì–´ ì¸ì‹ ìµœì í™”
              let enhanced = new cv.clone();
              
              // 1. ì–‘ë°©í–¥ í•„í„° (ë…¸ì´ì¦ˆ ì œê±° + ê²½ê³„ ë³´ì¡´) - ê°•ë„ ë‚®ì¶¤
              //cv.bilateralFilter(src, enhanced, 5, 50, 50); // 9,75,75 â†’ 5,50,50              
              
              // 2. HSV ìƒ‰ê³µê°„ì—ì„œ ê°œì„ 
              let hsv = new cv.Mat();
              cv.cvtColor(enhanced, hsv, cv.COLOR_RGB2HSV);
              
              // HSV ì±„ë„ ë¶„ë¦¬
              let hsvChannels = new cv.MatVector();
              cv.split(hsv, hsvChannels);
              
              // V(ë°ê¸°) ì±„ë„ë§Œ íˆìŠ¤í† ê·¸ë¨ ê· ë“±í™”
              let v = hsvChannels.get(2);
              cv.equalizeHist(v, v);
              
              // ì±„ë„ ë‹¤ì‹œ í•©ì¹˜ê¸°
              cv.merge(hsvChannels, hsv);
              cv.cvtColor(hsv, enhanced, cv.COLOR_HSV2RGB);
              
              // 3. ì ì‘ì  ëŒ€ë¹„ í–¥ìƒ (CLAHE)
              let lab = new cv.Mat();
              cv.cvtColor(enhanced, lab, cv.COLOR_RGB2Lab);
              
              let labChannels = new cv.MatVector();
              cv.split(lab, labChannels);
              
              // CLAHE ì ìš© (L ì±„ë„)
              let clahe = new cv.CLAHE(2.0, new cv.Size(8, 8));
              let l = labChannels.get(0);
              clahe.apply(l, l);
              
              // ì±„ë„ í•©ì¹˜ê¸° ë° RGB ë³€í™˜
              cv.merge(labChannels, lab);
              cv.cvtColor(lab, enhanced, cv.COLOR_Lab2RGB);
              
              // 4. ì–¸ìƒ¤í”„ ë§ˆìŠ¤í‚¹ (ì„ ëª…ë„ í–¥ìƒ) - ë¸”ëŸ¬ ì¤„ì„
              let blurred = new cv.Mat();
              cv.GaussianBlur(enhanced, blurred, new cv.Size(1, 1), 0); // 3,3 â†’ 1,1
              
              let final = new cv.Mat();
              cv.addWeighted(enhanced, 1.5, blurred, -0.5, 0, final); // ì„ ëª…ë„ ì¦ê°€
              
              // 5. ì»¬ëŸ¬ ì±„ë„ ì•½ê°„ ì¦ê°€
              cv.cvtColor(final, hsv, cv.COLOR_RGB2HSV);
              cv.split(hsv, hsvChannels);
              
              let s = hsvChannels.get(1);
              s.convertTo(s, -1, 1.1, 5); // ì±„ë„ 10% ì¦ê°€
              
              cv.merge(hsvChannels, hsv);
              cv.cvtColor(hsv, final, cv.COLOR_HSV2RGB);

              // ê²°ê³¼ë¥¼ ìº”ë²„ìŠ¤ì— ì¶œë ¥
              const outputCanvas = document.createElement('canvas');
              outputCanvas.width = final.cols;
              outputCanvas.height = final.rows;
              cv.imshow(outputCanvas, final);

              // ë©”ëª¨ë¦¬ í•´ì œ
              src.delete();
              enhanced.delete();
              hsv.delete();
              hsvChannels.delete();
              v.delete();
              lab.delete();
              labChannels.delete();
              l.delete();
              clahe.delete();
              blurred.delete();
              final.delete();
              s.delete();

              // ê³ í’ˆì§ˆ JPEG ë³€í™˜ (95% í’ˆì§ˆ)
              const result = outputCanvas.toDataURL('image/jpeg', 0.95);
              console.log(' ì»¬ëŸ¬ ìµœì í™” ì²˜ë¦¬ ì™„ë£Œ');
              resolve(result);
              
            } catch (error) {
              console.error(' ì»¬ëŸ¬ ìµœì í™” ì²˜ë¦¬ ì˜¤ë¥˜:', error);
              resolve(base64Input); // ì˜¤ë¥˜ì‹œ ì›ë³¸ ë°˜í™˜
            }
          };

          img.onerror = () => {
            console.error('ğŸ–¼ï¸ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨');
            resolve(base64Input);
          };

          img.src = base64Input;
        } catch (error) {
          console.error('ğŸ“¸ processImageBase64 ì˜¤ë¥˜:', error);
          resolve(base64Input);
        }
      });
    };

    // ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
    window.getProcessingStats = function() {
      return {
        mode: 'color_optimized_v2',
        features: [
          ' ì»¬ëŸ¬ ì •ë³´ ë³´ì¡´',
          ' ì–‘ë°©í–¥ í•„í„°ë§ (ìµœì í™”)',
          ' ì ì‘ì  íˆìŠ¤í† ê·¸ë¨ ê· ë“±í™”',
          ' ì–¸ìƒ¤í”„ ë§ˆìŠ¤í‚¹ (ê°œì„ )',
          ' ì±„ë„ ìµœì í™”'
        ]
      };
    };

    // OpenCV ìƒíƒœ í™•ì¸ í•¨ìˆ˜
    window.isOpenCVReady = function() {
      return window.cv && window.cv.Mat && typeof window.cv.imread === 'function';
    };

    // í˜ì´ì§€ ë¡œë“œì‹œ ì´ˆê¸°í™”
    document.addEventListener('DOMContentLoaded', async () => {
      console.log('ğŸ“„ í˜ì´ì§€ ë¡œë“œ ì™„ë£Œ');
      
      // ì¹´ë©”ë¼ ê¶Œí•œ ìš”ì²­
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        await requestCameraPermission();
      }
      
      // OpenCV ë¡œë“œ ì™„ë£Œ ëŒ€ê¸°
      try {
        const loaded = await window.cvReady;
        if (loaded) {
          console.log(' ëª¨ë“  ì´ˆê¸°í™” ì™„ë£Œ - OpenCV ì‚¬ìš© ê°€ëŠ¥');
        } else {
          console.error(' OpenCV ë¡œë“œ ì‹¤íŒ¨ - ìˆ˜ì–´ ì¸ì‹ ë¶ˆê°€ëŠ¥');
        }
      } catch (error) {
        console.error(' ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
      }
    });
  </script>

  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

  <title>sign_web</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>